{"pages":[],"posts":[{"title":"20161004","text":"大半夜的睡不着。一半是因为老家秋天的蚊子，大个，嗡嗡声能达数个分呗，一口一个大包；另一半还是每次回家都止不住的沮丧程序。看着年久失修，墙壁霉变剥落的房子；年老枯瘦依旧满面愁容的奶奶；年近七十依然紧闭大门外出劳作的外公外婆；满面风尘的舅舅，不沮丧也难。 想到车房妻子俱全的大哥，静待二哥结婚越活越年轻的姑父母，以及刚在上海买房的二哥，想想自己的工资与上海房价的比例，沮丧更胜之前。 就在几天前，还对朋友谆谆教导：最重要的不是别人有什么，而是你自己想要什么。当自己遇到了同样的境地，却也还是忍不住涌起各种情绪。不论是因为别人拥有的生活之艰还是生活之幸。 熬了一个半夜，看完了《从你的全世界路过》。之前并没有了解过作者，只是最近电影上映，亚马逊的 kindle 包月服务又能免费借阅，乘着家里没网，随便读读。也许是很久没有读这样的文字了，矫情的情绪弥漫到每个毛孔，又说不清楚矫情什么。现在，我已经完全记不得书里的任何一个故事了，只有那种情绪转化成忧伤挥之不去，只能呓语。 张嘉佳是幸福的，不论如何他还有故事有酒，他还有朋友，不管故事的真实度几分。我不会喝酒，也没有他那样的朋友。但我也是幸福的，父母俱在身体健康，有一只顽皮的小猫。只是书里面的人物只需要表达强烈的情感，不论困苦或者富裕，都不须理会世俗的欲望。而现实中的我，却始终逃不脱房车婚子这些事。也许是我太过浪荡，但心里总还是“诗和远方”。 傍晚和大哥聊起前次跳槽，不仅损失了十多万的股票，也并没有为简历添加更多的内容。从钱和潜在的钱的角度出发，真的已经可以判定是次失败的跳槽。但是想想自己得到也不少，自由的上班时间、自主的产品探索，当时也不是为了钱才跳槽的，算是给自己一些安慰吧。 读完书，觉的自己之前也是被长远规划和满心抱负蒙蔽太久，生活里充斥的只有代码。遂决定以后每个周末都去看看母亲，趁她下午休息，买杯果汁，聊上半小时一小时。我也不知道这其中的因果何在。 如果能找到一份远程的工作就好了，最好是国外的，那所有的梦想就实现了一半。","link":"/2016/10/04/20161004/"},{"title":"Flex &amp; Bison","text":"因为公司在用 phalcon，这种 c 扩展的框架 IDE 没有办法补全，所以想写一个把 zephir 转译成 PHP IDE Helper 的东西。本来想直接 Reflection 取一下类信息就好了，奈何最终效果不理想，本来 Zephir 中有的很多信息都丢掉了，注释也全部没有。所以还是要用 passer 转译。 只能说兴趣果然是最好的老师。之前编译原理看三段打瞌睡，死活读不下去，这下却是兴致满满了。只是Flex、Bison入门资料太少，网上写的那些文章都是浅尝辄止，完全没有可实践性。读手册又太过乏味。 看来看去，还是动物书的 Flex &amp; Bison 读起来舒服。 对于词法分析语法分析完全没有概念的同学，可以先看看这个 PDF 了解一下，再读动物书会好一些，不然有些没头没脑。内容基本和书里的第一章重合，但简单介绍了一下 Flex/Bison 是用来做什么的。 总结： 这个 PDF 动物书的 Flex &amp; Bison","link":"/2016/10/12/Flex/"},{"title":"Rust的模块系统初探","text":"学习一门编程语言，知道如何引用外部的文件或者说模块系统是比较重要的一点，PHP用autoload机制，C有经典的include。最近写 wslexe 的时候，因为原作者用的 rust，所以就简单学习了一下。但是 rust 的模块文档是从顶部设计开始写的，很多概念，有些复杂，这里写一个应用导向的学习笔记。 引入文件首先，让我们初始化一个项目。 1234mkdir rustmodcd rustmodcargo init 我们得到了下面这样的基础项目结构 12345rustmod├── Cargo.toml└── src└── main.rs main.rs里面只有一个简单的输出的‘hello world’的main函数。我们新增一个functions.rs文件，将生成字符串的过程做成一个函数，供main函数调用。 12345//file: rustmod/src/functions.rspub fn hello(name: String) -&gt; String {format!(&quot;Hello, {}!&quot;, name)} functions.rs就成为了一个单文件模块，rust 中称为mod，模块的名称就是文件的名称。模块内部的函数，只能在模块内部使用，如果要在模块外调用，需要用pub关键词，显式声明函数可在外部使用，我自己把这个叫导出函数。 下面我尝试在main函数中使用functions模块。使用的方式很简单，只要在使用前声明一下模块就可以了。声明模块使用mod关键字。使用模块内函数的时候，需要用::进行调用。 123456mod functions;//声明模块fn main() {let s = functions::hello(&quot;World&quot;.to_string());println!(&quot;{}&quot;, s)} 如果去掉函数前的pub关键词，编译器就会报错。 12error[E0603]: function `hello` is private 模块的嵌套rust 除了一个文件作为一个模块之外，还持支模块的嵌套。嵌套的方式，有两种。 第一种是在一个文件内，用mod关键字定义子模块。比如，我修改functions.rs 1234567//file: rustmod/src/functions.rspub mod util {pub fn hello(name: String) -&gt; String {format!(&quot;Hello, {}!&quot;, name)}} 同样，模块也是私有的，要在外部调用也需要pub关键字修饰。对应的main函数就要改为 1234567//file: rustmod/src/main.rsmod functions;fn main() {let s = functions::util::hello(&quot;World&quot;.to_string());println!(&quot;{}&quot;, s)} 第二种形式，是用文件夹来组织模块。文件夹的名字是模块的名字，rust 会去寻找文件夹下面的mod.rs作为模块的主文件，可以在里面写任意的 rust 代码，不过大多数时候用来输出目录内的子模块。我们来新建一个util文件夹，作为一个工具库的模块，修改项目结构 12345678rustmod├── Cargo.toml└── src├── main.rs└── util├── functions.rs└── mod.rs 在mod.rs输出functions模块。同样也需要用pub关键词修饰，否则就只是mod.rs文件内的私有子模块。 123//file: rustmod/src/util/mod.rspub mod functions; 修改main.rs中的调用 1234567//file: rustmod/src/main.rsmod util;fn main() {let s = util::functions::util::hello(&quot;World&quot;.to_string());println!(&quot;{}&quot;, s)} 总结rust 的模块由mod关键字和文件系统两者结合定义。mod关键字用来声明一个模块的名字，模块的内容或直接以mod NAME {MOD CONTENT}的形式书写，或根据严格的规则查找对应源文件。文件查找规则有以下几点： 查询声明模块的文件所在目录中对应模块名称名字的NAME.rs文件，如果有就作为模块使用。 查询声明模块的文件所在目录中对应模块名字NAME的文件夹，并且文件夹内有mod.rs文件，如果有就以mod.rs文件作为模块使用。 上面的规则都可以互相嵌套。 我尝试了在src目录下，同时存在util.rs和util文件夹，编译的时候报错 12error[E0584]: file for module `util` found at both util.rs and util/mod.rs 所以还有第四条规则： 在同一层级不能同时存在文件夹和文件类型的模块，否则会名字冲突。","link":"/2018/10/10/Rust%E7%9A%84%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%8E%A2/"},{"title":"VGA Text Mode笔记","text":"本文是 Writing an OS in Rust (Second Edition)第三篇文章VGA Text Mode 的阅读笔记，同时对文章中我觉得不太明白的一些内容做了一些扩展。 VGA Text ModeMemory-mapped I/O (MMIO) 是 CPU 驱动 I/O 外设的一种方式。简单得说，就是外设的操作地址（我不知道这里该如何解释）映射到了系统内存的一个区域，CPU 通过直接读写内存，来与 I/O 外设通信。 Text Mode 是显卡进行显示输出的一种实现方式。显卡将显示区域划分成一个二维的矩阵（类似 excel ）每个单元格对应一个文字字符数据。单个字符确切的像素数据由显卡控制。 VGA text mode，全称应该是 VGA-compatible text mode，是 Text Mode 的一种实现，用于兼容 VGA 的设备（或者说兼容 VGA 的设备，都有这种模式）。VGA text mode 规定，每个字符数据是个 2 字节的数据，前 8 位为字符的 askii 码，之后四位是文字颜色，再之后三位是背景颜色，最后一位控制是否闪烁。整个显示区域划分为 25 行 80 列（25行，每行80个字符）。 图片来自wikipedia，图里面是小端序，但我们编程一般默认大端序，所以是反的 CPU 通过 MMIO 的方式来驱动显卡的 VGA text mode。具体规则是在内存地址 0xB8000 处有一个25 * 80，单个元素 2 字节大小的二维数组（VGA text buffer），对应显示区域的 25 行 80 列的显示区域。每个数组元素就是一个单元格内的显示数据。程序只要指定读写该区域的数据，就能实现显示控制。 Volatile variableVolatile 的原意是挥发性的，不稳定。而 Volatile variable 指的是那些可能通过多种途径进行修改的数据。比如上面的 VGA text buffer，如果在程序中使用那么指针对应的数据，除了程序本身会修改，其他的程序也会修改，显卡驱动（bios?）也会修改。 这样的数据会有一个问题，就是很多时候对于单一程序只会进行读取/写入这种操作中的一种，比如 VGA text buffer 读取很多时候是显卡的事，程序则只负责写入。这样的数据，编译器会认为是没有意义的，很可能会在优化的时候被去掉，反而出现错误。所以一些语言中会把这样的数据标记出来。比如c、c++、java都有关键字volatile。MMIO 是 volatile 最常用的场景之一。 rust中没有 volatile 关键字，但是有一个 volatile 包可以实现相关功能。Volatile 包只有一个 Struct 即Volatile，实现 read/write 两个方法。这两个方法本质上是 instrinsics 包中的相关函数的包装，用来指示编译器（LLVM）行为。 几个attributeallowrust 编译器检查非常严格，比如 dead_code、unused_mut 之类的。通过 allow，可以让编译器忽略相关检查。完整的列表通过 rustc -W help 命令查看。 deriverust 编译器可以非常智能提供一些基本 trait 的自动实现。通过 derive 可以指示 rust 编译器做这些事情。derive` 指令支持的 trait 有 Eq, PartialEq, Ord, PartialOrd Clone Copy Hash Default Debug 文章里面用到了 Debug, Clone, Copy, PartialEq, Eq这几个 trait。 reprrepr 指示了编译器之后内容的数据在内存中形式。文章中设计到了下面几种 repr(transparant)。与struct中的第一个元素相同，一般用于只有单元素的struct，比如文中的ColorCode repr(C)。以C语言的方式存储。 repr(RUST)。以rust语言的方式存储，这个文章中没有，和上面那个对应，也是默认的值。 更多的repr可用值可以看这个文档。 macro_export类似pub的作用，不过作用对象是macro。 static和lazy static在 rust中 的全局变量，即 static 类型，其他方面都与局部变量相同，只有生命周期不同。static 类型变量有个固定的’static 生命周期；数据值会在编译期初始化，并在整个程序运行周期中存在。与const 类型的差别在于，static类型支持mut关键字，就是可以在运行时更改其数据。 static 类型如果在一个包中，同样也要依靠pub关键字，使得可以在外部访问。 由于static类型可以通过表达式来初始化，而初始化又在编译期进行，所以很多数据类型不能用于static类型的初始化（就是那些编译器推测不了数据大小的类型）。一种解决方案是用 const function，但是文中的例子用const function也不能实现（具体的我也还不是特别理解是怎么回事）。文中通过 lazy static 的方式来处理这个问题。 lazy_static 这个包，提供了一个lazy_static!的macro。直接把 static 数据类型的初始化包裹其中就可以了。比如文中的 12345678910use lazy_static::lazy_static;lazy_static! {pub static ref WRITER: Writer = Writer {column_position: 0,color_code: ColorCode::new(Color::Yellow, Color::Black),buffer: unsafe { &amp;mut *(0xb8000 as *mut Buffer) },};} mutex关于并发问题根源可以看 这个文章，说得比较清楚。 VGA text buff 只是在内存地址0xb8000上一个二维数组数据，但是从逻辑上它是一个I/O 资源。对资源的使用涉及到竞争的问题，尤其是上述还用了static 类型来保存全局的 VGA text buff 数据。 一般的编程中都会引入 mutex (互斥锁）来保证共享资源的操作安全。mutex是一个抽象上的概念，其本质是一种二元锁机制，即一个程序流（这里不想用线程，因为线程是操作系统概念，到目前为止还没到线程）要想执行操作 A，必须先判断另一个数据 B（一般是个 bool）符合一定状态（数据A是否使用中的状态）。而数据B的变化（compareAndSwap）必须是原子操作，这样才能确保数据B的变化是是顺序的可预期的。 一般 Mutex 包（比如rust的std::sync::Mutex）是需要用到操作系统相关功能的，这样可以在没有办法获得资源的时候让出cpu，并在锁的状态改变时唤醒。但是我们在写就是操作系统，所以文章中引入了一个不依赖操作系统的 mutex，即 spin 这个包中的 mutex。 spinlock所谓spinlock，简单理解就是用某种方式（比如while循环），使得当前程序流（操作系统一般就是线程）占满cpu，就避免了其他的的程序流来抢占cpu导致上下文切换进而发生资源竞争。说得通俗一点，就是原先cpu是谁着急谁用导致了资源竞争，spinlock使得我永远着急，所以等我用完你再用。 这里有一个用rust和spinlock来实现mutex的文章，可以用来帮助理解这些概念。spin 包中的 mutex 实现也比较简单，值得一看。 界面刷新算法界面的刷新基于一般的命令行界面规则，由下往上刷新，也就是在检测到当前行已经填满或者检测到换行符时，整体向上移动一行。对应到VGA text buff 上，由于数组顺序到界面的顺序为由上往下，从左往右的(x[0][0]是左上角第一个字符)，所以就是所有当前的字符，赋值给二级坐标减一的位置（x[i][j-1] = x[i][j]）。同时，最下面一行用空白填充。 界面刷新算法可以说是整个文章中最简单部分了。可以学习的更多还是对VGA text buff的抽象。具体实现在文章中很清楚，不再赘述。","link":"/2019/03/29/VGATextMode%E7%AC%94%E8%AE%B0/"},{"title":"WmDog文件处理流程","text":"最近开了一个新坑，需要做一个把美团外卖订单数据解析成单个菜品数据的工具。暂定名称WmDog。源起是一个朋友的实际需求。仔细想想，自从业以来，对于web上相关的文件系统处理仅止步于上传、保存，而这一次还需要后续的处理和下载。而且整个流程设计有一个明显的渐进过程，于是想要记录一下。 第一版的按照所需的功能进行了最简单的设计。 这样的设计符合最初的直觉，但根据经验，像解析数据这样的工作一般是不会直接放在api接口中进行的，更何况美团的外卖数据可能是以十万甚至数十万记录的量级。在用户端看起来很可是假死甚至超时了。 所以解析的过程需要放到任务队列中异步处理。 第二版设计中加入任务队列。 异步处理加入之后，前端可以通过查询任务处理状态持续给予用户反馈；只要保存好job_id可以做到稍后再看的能力。但是这一版设计中依然存在一些问题。文件的上传和下载都是通过web服务器进行，用户文件和解析结果文件也存储在web服务器。我们先不说如果web服务器崩溃导致文件丢失，单单是上传下载的带宽占用就是极大的浪费。web 就该好好干web的事，把文件处理交给专业的来做。谁最专业？自然是各个oss。 第三版设计中把文件存储交给oss。 这样修改之后还有一个好处：可扩展性。web服务器和文件存储、文件解析都分离了，哪里压力大，就可以可以只加那一部分的资源。比如任务队列消费不过来了，只要加一些worker进程即可。从某种程度上说，这样的设计也是一种微服务化的体现。 一个简单的例子。核心的思想是两个： 耗时任务放到异步队列中执行，既缓解服务器压力，又可以给用户更好的体验 切分任务，增加可扩展性。 水一文留着给自己看，没有多少干货。最后记录两个好用的程序。 python下的一个轻量级任务队列RQ 像写代码一样画时序图工具websequencediagrams","link":"/2020/03/31/WmDog%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"},{"title":"mdbook目录生成以及适应typora公式","text":"[mdbook](https://rust-lang.github.io/mdBook/) 是一个rust写的的在线图书生成工具。原本目录需要自己写，写了个小脚本来基于文件名自动生成。另外我平时使用typora来写markdown，内联公式的符号和mdbook不同，脚本里也做了替换。Show you the code。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import osimport remypath = './src/'pattern = '\\$[^$]+\\$'prog = re.compile(pattern, re.M)def is_md(file): return file.split('.')[-1] == 'md'def search_file(root): mds = [] for path, subdirs, files in os.walk(root): for name in files: f = os.path.join(path, name) if is_md(f): mds.append(f) return mdsdef build_item(title, link, rank): indent = ' ' * (rank - 1) return '{}- [{}]({})'.format(indent, title.strip('#\\n ').split(' ')[-1], link.replace(mypath, ''))def replace_inline_math(string): placeholder = '|-|' string = string.replace('$$', placeholder) mathes = prog.findall(string) for math in mathes: new_math = '\\\\\\\\({}\\\\\\\\)'.format(math.strip('$')) string = string.replace(math, new_math) string = string.replace(placeholder, '$$') return stringfiles = sorted(search_file(mypath), key=lambda x: '.'.join(x.split('/')[-1].split('.')[0:-1]).split('-')[0])summary = []for file in files: rank = len(file.split('/')[-1].split('.')[0:-1]) result = '' with open(file, 'r') as f: title = f.readline() summary.append(build_item(title, file, rank)) result = '{}\\n{}'.format(title, replace_inline_math(f.read())) #print(replace_inline_math('$$adfad$$adasdfasdf$asdfasdf$')) with open(file, 'w') as f: f.write(result)print('# SUMMARY')print('')for l in summary: print(l)","link":"/2020/04/17/mdbook%E7%9B%AE%E5%BD%95%E7%94%9F%E6%88%90%E4%BB%A5%E5%8F%8A%E9%80%82%E5%BA%94typora%E5%85%AC%E5%BC%8F/"},{"title":"windows登录自动化 PPTP","text":"前情提要公司网络管制严重，之前就很多正常网站不能访问，最近更是直接屏蔽了外网的ssh，导致我自己的服务器不能登录操作。无奈只能一直使用 PPTP 连回家里网络上网。这本来没什么问题。但是测试服务器和很多公司服务都是公司的内网网段，连上 PPTP 这些地址都不能访问了，需要自己手动添加路由表设置。这本来也也没什么问题。但是每次电脑睡眠回来，都要重复连接 PPTP、执行路由表添加命令，真是不胜其烦。秉着程序员就要自动化的原则，就下决心要处理一下这个事情。 思路自动化的本质其实就是脚本化。经过一番搜索我找到如下相关信息。 windows下连接系统设置的VPN的命令是 rasdial,基本格式是 1rasdial &lt;VPN NAME&gt; &lt;USERNAME&gt; &lt;PASSWORD&gt; route ADD命令添加路由表，对于我公司10.*.*.*网段简化格式如下 1route ADD 10.0.0.0 MASK 255.0.0.0 &lt;GATEWAY&gt; windows下定时执行工具叫 Task Scheduler（任务计划）,是个 GUI 程序，并且可以设置触发器不用循环执行。 所以整体思路就是创建一个脚本检查当前网络环境，是否是在公司内部，如果是在公司内部并且没有 PPTP 连接就执行rasdial和route命令。 脚本12345678910ipconfig | findstr /n 10\\.4\\.90\\.[0-9]*IF NOT ERRORLEVEL 1 ( ipconfig | findstr /n 192\\.168\\.123\\.[0-9]* IF ERRORLEVEL 1 ( echo AT COMPANY AND NO PPTP. rasdial &lt;VPN NAME&gt; &lt;USERNAME&gt; &lt;PASSWORD&gt; route ADD 10.0.0.0 MASK 255.0.0.0 10.4.90.1 )) 设置任务计划任务计划设置直接GUI操作没什么好说的，就注意两点 常规选项卡上勾选以最高权限执行 触发器添加在工作站解锁时运行 完美。","link":"/2019/08/15/windows%E7%99%BB%E5%BD%95%E8%87%AA%E5%8A%A8%E5%8C%96PPTP/"},{"title":"一个博客的诞生","text":"题目有些标题党了，其实只是想聊一下自己的用的博客程序，因为有人留言说博客打开很快。老实说，这东西其实够不上“程序”，因为只是两三个脚本配合着一些现成的工具，做了一键部署罢了。 我对用 gh-pages 做博客一直有一点怨念，觉得 Hexo 之类的都太麻烦：先要安装执行环境，然后安装生成器，然后一大堆的配置文件，部署的时候还要反复的敲命令，clean、generate、deploy之类的。但是另一方面还是，还是很想用 gh-pages 做博客。除了免费速度也不错之外，最主要的还是 git 版本管理的特性，以及可以直接用自己喜欢的编辑器来编辑。各个生成器对 markdown 之类的标记语法也都支持得比较好，不用像在网页上写一样格式不断调。可能真的是到了阮一峰老师说的博客三阶段的最后一阶段了，想要的就是一个简单快捷的记录和发布文字的地方。 但是我一直都没有找到这样的 gh-pages 生成程序。其实最理想的情况是直接一个单页应用， 基于 github 提供的 API 来获取文章的内容，前端渲染。自己也尝试着实现过一个。但 API 毕竟不是用来搞博客的，排序、标签等等很多功能要么没法实现，要么实现起来很麻烦甚至对编写和目录结构提出了要求。最后也还是没继续做下去，也没有用起来。 后来觉得，不就是各种步骤要手动麻烦吗，作为一个程序员最不应该怕的就是这个了啊。于是就开始慢慢地一点一点组合这些工具，写一点脚本。因为在家里用的台式是 windows 所以也做了 windows 的适配。目前已经，个人觉得，已经把安转和配置过程最简化了。除了 python 和 git 要自己装，其他的就是部署一个脚本要在一开始执行一次，发布一个脚本在每次写完文章后执行一次。 详细的安装和使用过程已经在项目的介绍里了，欢迎 star 和使用反馈。 所以说，偷懒才是第一生产力啊。","link":"/2017/02/04/%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AF%9E%E7%94%9F/"},{"title":"一些重构体会","text":"最近在重构多媒体服务，包括爬虫和搜索两部分。原先的代码是一个实习生 Q 同学写的，用的 python。如果抽出其中的一块代码来看， Q 同学应该是一个重实践的同学，代码质量还是很不错的，但是之前看的时候我还是很难理解他的编程思路。直到这次彻底的重构，才发现代码中的一些问题。 这里记录下来，也是对自己的提醒。 命名这其实是一个老生常谈的问题，而且大部分人其实都有这个意识，Q 同学在对待大部分的命名上也都在尽量选择合适词汇。但是，对于工具函数却没有一视同仁。 比如 12345def _l(x): r = list(map(_ft, x)) if len(r) == 1: r = r[0] return r 这是一个内部函数，用来提取出爬取的元素，并根据获取的元素数量返回不同的数据结构，在爬取数据的时候多次用到。即使不用太高级的英语，直接用 get_result_as_list_or_string已经可以极大地缓解在阅读过程中返回去看这里干了什么的情况。同样的，用 x、r之类的做变量名， 虽然我可以明白这个函数在做什么操作，但是我并没有办法把它和业务的某一部分联系起来。 这样的例子在整个源代码中还有很多，虽然最后还是可以看懂，但是读起来就不怎么舒畅。 保持程序的轻量这个各人可能会有不同的习惯。我不喜欢在功能很简单的时候就引入太重量级的东西。比如，如果你整个程序只有五句 SQL，那为什么要引入一个 ORM。 多媒体服务中，一共不会用到超过10个 ES 访问，而且这些访问的语句是固定死的，也不会频繁改动。ES 的访问就是简单的 Http 请求， 所以自己写个文件来处理并不会很麻烦。但是一旦用上了 elasticsearch-dsl-py, 我除了要理解 ES，还要理解这个库的用法，就为了那不多的几个 ES 请求。 同样的，后台系统中是有开放可用的队列服务的，为什么一定要用 celery 来复杂化这个事情，还导致重建 ES 索引这样的任务必须要用 api 才能下发。 以业务逻辑而不是功能对代码分层按照我看代码的情况，原先的设计中包括一个接口层，一个爬虫层，一个搜索引擎的实现层，最底下是支持各个层的 lib。 Q 同学做了很多的功能划分：一个 api 文件夹放所有的 api 实现，一个 engine 文件夹放各个源的搜索、爬取和索引的实现文件，一个源一个文件夹。 如果严格按照这样的方式来组织文件，到也不错，问题在于，Q 同学把 ES 相关的东西也放了进去，也许是觉得 ES 也是一种搜索实现吧， 但是 ES 的数据模型等其他信息也一并放在了这里，这就让刚读代码的我有些搞不清自己之前的阅读思路是否是对的。 实际上，整个业务逻辑是这样的 用户发起搜索 –&gt; 社区程序向多媒体服务发起搜索请求 –&gt; 调用搜索接口，使用 ES 来搜本地库 –&gt; 使用用户的搜索词去爬取、更新数据 所以，ES 虽然也是搜索，但是在中业务的层次是和这里的 engine 不同的：同样是 search.py, ES 下是真的搜索，其他的其实是各个爬虫的组件； 同样是 job.py, 各个源下的是爬虫任务，ES 下的则爬虫的触发器; 另一个问题是，因为是按照爬取的目标不同而进行的划分，所以在努力地爬取功能下完成各个工作，导致许多重复的工作。如果按照 爬取-&gt;整理-&gt;入库-&gt;索引 流程，各个爬虫只要返回的多媒体数据结构一致， 入库和索引的步骤都可以用统一的实现。 最终重构的时候，我去掉了 api 层，把搜索放回了社区程序，因为总共只有2 ~ 3个 ES 查询，且是强业务的功能，没有必要放在这样以爬虫为主的程序上， 还需要一层 api, 用上 flask。爬取任务的触发就用 job 形式直接下发到队列。整个程序就按以下的流程来组织了。 任务监视器 –&gt; 爬虫 –&gt; 入库 –&gt; 索引 又因为，去掉额外的爬取源，所以合并了爬虫和入库。 结语代码是我写的，但是以后阅读和维护代码的人并不一定是我；我现在知道这里为什么这么写，一个月后未必知道。 所以写代码的时候要多想想应该如何保持简洁和逻辑的通顺，多问问我为什要这么写。","link":"/2016/12/09/%E4%B8%80%E4%BA%9B%E9%87%8D%E6%9E%84%E4%BD%93%E4%BC%9A/"},{"title":"一点技术管理思考","text":"最近找工作面了个CTO职位。明知不可能还是要试一下，主要是那个职位的描述真的很复合我的口味 。为了提高成功率尝试写了一下自荐信。奈何刚写完，面试结果就出来了。啧啧。 文章中其实更多的还是自己对于技术管理的一些思考，核心就是效率和稳定性两个点。留着记录一下，不然哪天又找不到了。 与贵公司HR沟通之后，我又搜索了一些资料，加深了对聚创医药和相关职位的了解。我想从几个方面来简单说说自己与这个职位的想法。 首先是技术能力方面。自从工作以来，我所经历的团队都是相对精干的团队，对每个人的能力要求都是在自己的主要职责之外要对其他的开发工作适当涉猎，这样才能在合作的时候理解各方的诉求，才能全面地评估技术实现的难度，才能更合理地安排开发时间。尤其是作为项目地主导者时，更是对此有比较高的要求。用时髦的话说，就是“全栈”能力。我个人在这方面投入的精力较多，后端为主，前端次之，运维测试也有都了解。此外，我经历过各种类型的项目，从传统的信息管理系统（百姓网）到交易系统（乐空空），从社交和聊天软件（Same）到企业内部工具（诺亚财富），对不同类型的项目从立项到技术方案到推进落地都有完整的认识。从与贵公司HR的沟通中了解到企业目前IT部门的现状与未来的一些规划，我想我在这些方面的经历和经验应该会对公司的发展有所帮助。 其次是技术管理的方面。从百姓网到Same到诺亚，我所经历的三个企业是非常典型的三种类型的企业，也是三种典型的技术管理方式。Same是完全的创业公司，团队小，基本没有层级架构，所有人一起对业务对产品负责，采用的是快速试错的开发方法；百姓网的工程师文化非常浓厚，技术人员的话语权很高，崇尚的是扁平化的人员管理和敏捷式的开发方式；诺亚则是传统企业的IT管理方式，高层决定方向，中层决定事务，底层负责执行，注重流程与制度。对于软件开发来说，技术管理的核心指标其实只有两个：开发的效率和产品的稳定性，当开发资源（人数、能力、时间）有限的时候这两个指标通常是冲突的。技术管理的作用就是在开发资源有限的前提下，充分利用资源，平衡效率与稳定性。上述三种典型的开发管理方式效率依次递减而稳定性依次递增。在三家公司我自己的管理方面的实践大部分时候是处在中间层次，对上要参与项目计划，对下要参与具体实施，在这个位置上可以看到不同类型管理方式是如何在效率和稳定性这两个核心指标上影响项目的推进。 技术能力和技术管理是我自己有所实践和有自信的。后面要说的另外两面是我有所思考，但因为职位所限而没有真正的实践的。 一个是关于开发人员的考评与激励。这个其实一直是业界的难题。由于软件开发的智力创意因素，很多时候数量（代码行数、BUG修复率等等）并不能真实地反应工作成果。这就导致了软件开发人员的KPI难以制定，人员考评尤其是绩效考评也困难重重。另一方面，软件开发是一个团体作战的工作，任何一个点位出现问题都会导致最终的产出出现问题，比如交付时间延长和产品不可用（宕机、bug等）。基于这个原因，个人比较认可的是基于团队的集体绩效，考评的对象是团队产出产品的各项指标，并且基本是负指标，比如交付延迟时间、服务不可用的时长等。用负指标的原因在于，软件通常是与业务相互匹配的，做到100%之后继续往上提升并没有实际效益。至于人员的激励方面，就我自己的亲身经历和周边各种同事的反馈来说，一个技术人员在优秀技术氛围中获得的成长和激励，远远大于其他方面的激励。 另一个则是关于团队建设的。我认为还是要从软件开发的基本目标出发来看待这个事情。个人对于技术团队的看法一直是贵精不贵多，原因也是软件开发是一个团队工作，木桶效应显著，不一定说一个优秀的开发一定能顶几个普通的开发，但一个较差的开发一定会拖慢团队的进度。这是效率方面的考量。团队的梯队建设其实并不一定是必须的，因为梯队建设的目的主要还是在开发人员流动频繁这样一个事实下，能够保证软件开发流程不会因为人员流动出现问题。使用梯队方式形成备份是一种方式，但更多适用与团队规模相对较大，有比较充裕的head count的时候。对于小团队来说，更好的方式是开发人员的互相备份，不能让某一块业务只有某个单一人员了解甚至专精。这可以通过code review(提高代码可读性)、交叉业务开发、技术沉淀等一些手段来达到目的。另一种意义上的人才梯队建设本质上是人才储备，这已经脱离软件开发本身，是公司战略层面的内容，开发人员在具体的选拔和培训指标上可能有所不同，但思路上和运营，销售，客服等等都是一样的，这方面我还是不班门弄斧了。我经历过的做的最好的是百姓网，从校招开始到mentor机制到实践历练，自己也是在百姓网的两年获得飞速的成长。 上面的所有内容都是自己这些年对工作经历的一些总结。我知道从经验来说我在许多方面还是欠缺的，尤其是在人员管理上面。我个人的优势则是经历过的管理模式够多，可以理解不同管理模式的优缺点，不会生搬硬套，限于前公司固有套路的窠臼。在个人意愿上，我对这个工作非常在意。一方面是我自己的化学背景的专业出身，我的大学室友在重庆的药企做研发，一些同学在从事医药销售。另一方面也是自己的职业追求，个人认为软件开发的最终目的还是适应业务，创造工具，提高效率。如果贵公司的招聘期许，是能够找到一个可以使得快技术团队速扩张，一步到位，我想我是不合适的，也自认为没有这个能力；但如果是期望技术团队在保证效率与稳定性的基础上，适应业务逐渐成长，我想我的一些经历和想法能够提供帮助。 期待与公司和公司的技术部门共同成长。","link":"/2020/06/01/%E4%B8%80%E7%82%B9%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E6%80%9D%E8%80%83/"},{"title":"个人成长与工作","text":"其实12点不到就睡了，但是一直睡不着，又不想写代码，担心一写又到早上了。所以还是来写写鸡汤吧。 从实习算起，参加工作也又三年了，对于工作与个人成长的关系也算是有自己的一点理解。恰好之前与人讨论了一番，感觉值得梳理一下。 首先，我觉得工作是公事而个人的成长是私事，企业有义务帮助员工适应工作环境(对于实习生来说这包括必备的工作技能)，但并不对员工的个人成长负有任何责任。所以，一般培训一项是作为福利存在的。至于人才培养计划之类的，那是企业在对人力资源的成本衡量后的结果。如果引进人才的成本比较低的话，我想没有企业会花这笔钱。明确这一点之后，才明白为什么渡过了最初期的适应阶段之后会觉得自己不再长进了，因为一旦你可以胜任工作之后没有人会再催着你学了；如果出现一项你无法胜任的工作，很多时候都是安排有能力的人去做。 从这里也可以看出，为什么说八点到十点的两个小时，才决定了一个人发展：因为工作时间，企业对你的要求就是重复你已有的技能，而你却想从中获取新的技能，那可不是缘木求鱼；只有工作后的自我学习，才是真正属于自己的，习得新的技能的时间。如果用这些时间获取了新的技能，而下次出现了需要该项技能的业务，那不就可以在其他人中脱颖而出了么。想象一下，一个流水线上的工人，如果在课后自学了机器的运行原理；在某次机器故障，所有人都无所适从的时候，试着解决了问题，你觉得老板会不会考虑安排他去跟着老师傅学习机修？ 当然，这种机会是可遇而不可求的，所以称为机遇.而我们能做的是在做好准备的同时，让这种机遇发生的可能性尽量提高一些。因此，学什么就很重要。我的经验是，去学和工作紧密相关的。听起来很虚，但其实很简单。比如我，并不是计算机科班出身，加入互联网行业时基本是空白。在刚开始工作，学会了用框架提供的接口来增删改查写业务逻辑之后，已经满足了工作的基本要求，似乎已经没有什么可学的了。只是那段时间正是对编程知识如饥似渴的时候，无意识地希望了解框架背后的原理，去真正的理解OOP、MVC、Restful这些高大上的名词，也恰好遇到了一个好的老师耐心指导，虽然这些东西对于写当时的业务逻辑其实并没有什么用（其实还是有点用的），但当新的产品计划出来，可以参与后端架构是我，而不是同期的其他人，我觉得还是有挺大关系的。 工作的内容是一个点，除了把这个点画大，更可以做的是找到相关联的点，把他们连起来——这是从开垦到跑马圈地的变化。深化自己的已掌握的知识，让点变成圆，可以有更长的边界去连接更多的点。这样能力才可以即保有深度，有扩张广度。所以，我还是挺喜欢工作总结的，可以把工作内容这个点描述清楚，知道自己的边界在哪里，这样才有的放矢。 总结起来，个人成长与工作的关系是一句鸡汤的无比的话：从工作中来，到工作中去。","link":"/2017/01/02/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF%E4%B8%8E%E5%B7%A5%E4%BD%9C/"},{"title":"周记2020-12-14","text":"长期不写东西，指头和脑子已经生疏了。刚刚脑海中还有无数的念头闪过，一面对跳动的光标，就只剩屏幕反射的房顶灯光了。之前也算不上什么厉害的写作者，但至少还是能写的出话来。键盘的敲击，落下得不能只是代码了。每天写日记比较难以坚持，一周一篇周记还是可以尝试一下。 上周的前半周还是一样的物料，合并后新公司的所有事务都在计划中，落在我们基层员工上就是冒然无措。所谓的技术优化好像也与我关系不大；自己也没啥兴趣主动参与。每天没事做其实也挺煎熬的，毕竟也不能真的明目张胆的摸鱼。 后半周在电鸭上看上了一个日本的 remote 岗位，投了简历，做了笔试，约了这周四下午面试。简历和笔试都过得很快，不知道是不是该感叹创业公司的缘故效率就是高。remote 的薪水并不是很高，联系的时候也说我填的薪资超过了岗位限制。问了下薪水的发放是日本日元直汇，如果能拿到20K的JD最高值，也勉强还行。虽然在上海捉襟见肘，但从长远考虑，这个薪水到成都的话就比较合适了。远程工作时间比较自由，想补足收入也可以其他的办法。 现在面试没有早几年那么胸有成竹了，可能之前找工作都太过顺利。最近我觉得挺好的机会都栽在了算法上。不是科班出身，算法能力没有集中突袭，虽然平时零散的学习在工作中够用，但面对算法为主的面试时还是力不从心。如果这次还是倒在算法题上，那真的要花费一段时间认真集中补习一下。 周末去了南京参加秋叽叽的婚礼，慧慧也回来了，还有一个半月也到我婚礼了。还有挺多东西没有准备，但慧慧似乎已经对婚礼不怎么上心了，我又不知道该怎么提醒她或者开口和她商量。 是我欠她一个理想的婚礼。","link":"/2020/12/14/%E5%91%A8%E8%AE%B02020-12-14/"},{"title":"回归社交","text":"之前在知乎一个关于外国人吃的问题下面，一个答主描述国外的“约饭“不像国内一样，不是真的是以吃为重点，而是以吃为由头，一群人聚在一起聊天，食物只是调剂。 同样是约饭，在他们看来不过社交的一种形式。似乎社交就是聊天，或者说交流。可是交流本身并不能构成社交。 互联网时代的社交是怎样的呢？以 Facebook 和 Twitter 为代表的点赞，以微信为代表的 IM 还是各种速配应用？这些似乎是又不全是社交。 Facebook 偏表达，IM 偏工具，速配偏认识。原先没有互联网的社交是怎样的呢？对于熟人社交，我们起个由头，约个时间，组织活动，交流各自见闻，回忆回忆往昔， 男人们讨论时事， 女人们唠叨家庭。对于陌生人社交，我们参加一个公共活动（桌游、酒吧、音乐会等等），因为某个特质而欣赏某人，搭讪，聊天的时候展现自己，观察对方。 可能留下联系方式，期待后续的交流。 熟人社交，即使来到了线上，但因为彼此的熟悉，所以没有特别的了解对方的需要，只有知道对方的近况和充分的交流需要，微信在满足了这一需要。 陌生人社交中的一部分，仅仅是猎艳，所以目标就是快速适配，陌陌们在满足这一需要。至于 Facebook 、微博，注重即时信息发布的特质，使得媒体属性要强过社交属性。 可是这里还有一批人，他们需要陌生人社交，但不是以猎艳为目的，而是仅仅希望认识有趣的人。以前的豆瓣在做这一部分，互联网上把这部分叫兴趣社交。 但基于兴趣的社交，只能遇到志趣相投的人，只是有趣的人的子集。 一个人在社会上生活，他的所作所为和所思所想成了他在社会的存在。不经意间，我接触到了他的在社会留下的痕迹，觉得很有意思，我很想认识这个人，与他交流。如果是在现实， 这简直是个不可能的事。而在互联网，我就可以轻易的联系上他，这样的兴趣社交–对某人产生了兴趣并期望与他发生社交的社交，没有大的应用在做这个。 兴趣是小众的，而对他人产生兴趣是大众的。 想象了一下，如果我来设计这样一个应用我会做些什么？想了一下还是会像 same：分出个人与公共的空间，在个人空间留下自己的私人内容，在公共空间参与集体活动这样的基本架构。 但是细节上，我会希望 App 本身不做任何的限制和引导，把权利特别是对公共空间管理的权利交给用户，这样每一个空间才会是个性化的，而不是千篇一律的。 要有好的交流工具，满足从浅到深的各种交流的需求。去现实化，不把现实的身份带上，只把作为一个人的特质带到线上。 这样的应用要产生真正的社交接触是很慢的，就像一个人来到一个陌生的城市。而且，形成了这样的氛围的时候，对新人会不友好，因为没有痕迹，别人就没法对你产生兴趣，这是个难处。 还有一点很重要：不要做推荐，让一切平等地等待被发现，否则就又会陷入兴趣的窠臼。不过，要给用户提供好发现的渠道，这个很重要。","link":"/2016/11/03/%E5%9B%9E%E5%BD%92%E7%A4%BE%E4%BA%A4/"},{"title":"中数据分析","text":"same 在前段时间更新了数据的展示形式，数据流的方式意味着决策上将要更多地向个性化的方向发展。说到个性化，那就意味着大量的用户行为数据的收集和处理，意味着原先用 MySQL 还能支撑的统计分析将不再适用。因此，开始考虑需要一套大数据处理的工具。说到大数据，一般都会自然得想到 Hadoop 系的一系列工具，从计算引擎，到存储系统，再到查询工具。Hadoop 的这一整套东西，很好很强大，但也意味着架构的复杂。 作为一个之前没有接触过任何 Hadoop 系统地超新手，我们艰难得尝试了几天，最终还是选择了放弃。放弃的原因，除了复杂度之外，更是因为一种杀鸡用牛刀的感觉。即使是全量的记录 same 的访问日志，每天也不过数 GB，这样的数据量，要直接上动辄十数台机器（hdfs + Hadoop + 控制节点）的集群着实有些奢侈（费用和维护成本）。而且，公司里也基本没有对 Hadoop 体系熟悉的人，后续的知识传承也很成问题。放弃了 Hadoop，就要重新寻找这样一种简单又可扩展的替代品：架构简单，用少数机器甚至单机即可组建；快速的扩展能力，来应对后续可能的数据增长。 中间寻找评估各种软件的过程略过不表，最后选择了 Cassandra + Spark 的组合。 Cassandra 同样脱胎于 Bigtable，借鉴了 Dynamo 的存储方式。对称节点的设计比 master-slave 的结构更加简洁而容易理解，也减少了组建集群的难度；虽然是 key-value 列式存储但和 RDMBS 类似的 table 概念，类似 SQL 的查询语言 CQL，使得它更好上手。相对于HDFS + HBase 的组合可以说相当轻量了。而 Spark，RDD 的高速，计算的通用性，以及简单的 API 都让它成为了不二选择。在初期，用 standalone cluster mode 也可以显著得减少建立和维护集群的消耗。更重要的是，Cassandra + Spark 的组合有 datastax 商业实践在先，相信即使是真·大数据的处理也可以支撑得起来。 目前，same 在腾讯云上，用四台机器搭建起了一个超小型的数据收集和处理的集群，而扩大这集群需要只是购买一台机器，执行软件安装脚本，修改配置文件。随时应对产品锦鲤的粗暴需求。 有了集群之后就是一些软性的配套需求了。我们简单规划了计算程序（用 Scala 并打包成 jar）的结构和部署目录，使得可以用统一的命令接口启动一个任务。利用了之前只有前端同志在用的 jenkins 做持续集成和自动部署。后续可能还需要一个启动任务的 web 界面，免去每次跑单一任务都要登录服务器的繁琐。实时计算目前还没有需求，但也在考虑中了。 我不能说，这样的处理方式一定是最合理的，但对于有数据处理的需求又没有达到真大数据规模的阶段，还是值得一试。对于小公司来说，在满足需求的前提下，能省则省，毕竟已经不是几年前啦。","link":"/2017/06/19/%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"title":"初始化一个 Python 开发环境的正确姿势","text":"在看这篇文章的时候，我需要两个假设，以避免做过多无关的解释。 假设读者对 Python 有最基本的了解，知道如何使用 pip。并且系统环境中已经安装有 Python 和 pip。 假设读者对 virtualenv 有最基本的了解，知道为什么要用 virtualenv。 如果假设不成立，可以跟随上面的链接和 Google 来了解。 0x1 更换 pypi 源为豆瓣的源如果网络环境好的话这一步也可以不做 123mkdir -p ~/.config/pip/touch ~/.config/pip/pip.conf 在pip.conf 文件中添加以下内容 1234[global]timeout = 60index-url = https://pypi.doubanio.com/simple/ 0x2 安装 virtualenv12pip install virtualenv 0x3 使用 vritualenv 初始化应用目录123virtualenv path/to/your/app/folder/source path/to/your/app/folder/bin/activate # 激活环境 virtualenv 初始化的时候可以有多种基本Python的环境选择。新版本默认是不会带上site-packages的干净环境。 0x4 安装依赖比如 Flask 12pip install flask 或者如果有requirements.txt的话 12pip install -r requirements.txt 0x5 把 virtualenv 环境导入编辑器/IDE这里仅以 VSCode 为例。先安装 python 的语言插件，然后编辑 workerspace settings 增加以下内容 12345python.autoComplete.extraPaths: [ path/to/your/app/folder/lib],python.pythonPath:path/to/your/app/folder/bin/python 之后就可以愉快的使用了。","link":"/2016/12/10/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"},{"title":"当我们在编程时我们在做什么","text":"先让我们把计算机想象成一个人吧。一个人总要有个名字，就叫他小明吧。 小明可以帮我们做一些事情，比如说算一下 256 乘以 1024 等于多少。这种问题对我们自己来说，按照乘法规则算一下也能算，就是麻烦，可是对小明来说算起来可很简单，这是小明擅长的领域。不过这个小明并不能理解你所说的“256 乘以 1024 等于多少”这句话。因为小明是一个外国人，他只说自己的语言。就像你和一个图瓦卢的人说“告诉我 256 乘以 1024 等于多少”，我想他也会一脸莫名奇妙。小明也是这样，不能理解你的意思。我们只能用小明的语言来告诉他要做什么。 小明说的语言就是编程语言，比如说下面这样的。 123int result = 256 * 1024;printf(%d,result); 也许你一点都看不懂，没关系，刚学英语的时候我们也看不懂 “How are you? Fine, thanks, and you?”。也许你现在能看得懂一部分，比如知道256 * 1024是在做乘法，printf好像和打印有关系，就像我们看日语靠着汉字也能猜到几分意思。 现在，你只要知道，小明说的是一种名为编程语言的语言。小明可以帮我们做一些事情。但我们只能用编程语言来告诉他我们需要他做什么。 所以，当我们在编程的时候，我们在做什么呢？我们其实就是在用编程语言，告诉计算机（小明），让计算机处理一些事情。 其实编程这件事本身，就是这么回事。","link":"/2018/08/13/%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8%E7%BC%96%E7%A8%8B%E6%97%B6%E6%88%91%E4%BB%AC%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88/"},{"title":"我","text":"从14年一月份进入百姓网开始全职实习算起，参加工作也三年又两个月了。去年后半年从百姓网离职，来到 same，希望能为我喜欢的产品出一点力。但是六个月过去，虽然 same 给了很高的自由度，也没有太大的作为。除了产品上的问题之外，可能还是作为技术人的能力并不如自己所想的那样，已经到了可以做出哪怕些微的创新的地步。所以最近的两三个月一直都在感到焦虑，重新感到了工作之初时那种觉得自己什么都不会的感觉。不过区别是，彼时觉得自己是萌新，学习能力有自信，那种认为自己什么都不会的感觉可是强大的学习动力。而此时则是短暂的膨胀期之后的幡然醒悟，是一种失落。 我很喜欢编程。准确的说，我喜欢所有和创造有关的事物，讨厌重复劳动。可惜本身手残，小时候也没有条件去接受艺术的熏陶。好在，有编程这个纯粹脑力的创造活动。怀着一腔热爱进入这个行业，但从一开始工作，就对自己的非科班出身的经历耿耿于怀，总觉得心里很慌。可真的去尝试学习的时候，则感觉那些东西在工作中真的很难用到，理解一些基本概念后就不怎么愿意花时间去做练习巩固，然后心里依然很慌。 直到去年接近年末的时候，才想明白，心慌的原因并不是不会，而是不知道自己究竟会什么，或者说没有什么东西来证明自己会什么。 对自己只有模糊的感觉：能力水平还可以，正确理解业务并实现以及处理常规的性能问题都没事问题；技术的深度不行，深入底层之后比较无力；广度还可以，半个全栈，基本可以一人包揽从运维到前端的大多数工作，不过前端技能树杂而不精，只能应付简单的业务。然而这些只是个人评价，而不是自我理解。没有细节的理解都是耍流氓。而且也没有什么能明确的证明这些评价的东西，毕竟平时做的都是再平常不过的工作。唯一自我感觉良好的，是代码结构的设计，但这真的没法构成一个可以言说的点。 认识你自己！贤哲这样说过。 不知道会什么，就没法摆正自己的位置。连自己都不知道自己会什么，那面试的时候，当然也就没法给别人说清楚，把自己的能力展现出来，只能跟着面试官问一句答一句。于是最近一段时间尝试了很多方法，希望可以把自己的能力表达出来。试过个人维基、试过思维导图，但总觉得不对味。 维基太过分散，思维导图太过笼统。想来想去还是需要用文字系统化地组织自己的知识。但文字与维基的不同在于，需要有一个行文的线索，不然不仅无从写起，也无法达到系统化的目的。没有系统化，对自己的认识依然是模糊的。","link":"/2017/02/20/%E6%88%91/"},{"title":"整理","text":"2014年毕业，按照毕业算工作年限是四年，如果是2014年初的实习开始，就快五年了。五年来，从一无所知的小白到现在前端后端都能写，虽然自认业务能力充足，但很多时候还是带点心虚。 有的时候不得不承认，不是科班出生的，总归是要比别人慢一点。当别人已经开始学习大数据、AI、区块链的时候，我还在补数据结构、操作系统、编译原理，还补得磕磕绊绊。五年了，因为没有系统的检验，即使学了，还是不明白自己究竟有几斤几两。对事物的控制欲望让我想知道方方面面的细节，否则我就不放心。对于自身也是一样。虽然我知道面对寻常的后端开发工作，90%以上的工作都可以胜任，但只有在问题出现的时候才能判断这件事是否在这90%之中，让我非常的焦虑。这种焦虑，有点像以前做数学考卷的时候，知道某个题是用什么知识点来解的，但能不能解出来，还得算来看看——本质上是知识没有条理性。 最近一长段时间，大概有个一年半，尝试过用一些方法来梳理自己的知识体系。用过思维导图，感觉太过简单；用过wiki，但会陷入到细节中拔不出来。不管怎么做，总是不那么如意和顺畅。做准备工作的时候，明明觉得提纲里的东西都用得顺手，但是实际写来却艰苦卓绝。最近想明白了，我自己的心里本来是没有把所有的东西理顺的，总结的提纲挈领的东西，有一点缘木求鱼的意思。所以，这次我将尝试用重新学习方式，来总结一些自己在后端开发领域的知识。这种总结有点像期末复习，对应的期末考试就是面试了。 真正的期末复习有课本可循，科科目目比较明白。但自己这次复习，没有课本，科目上也只能自己设置了。目前后端开发上大致要包括下面一些组成。 语言基础。这里选择了PHP，因为是我自己的工作语言。其实对于后端开发来说，用什么语言，除了语法和库用法有些区别，基本套路是相似。所以即使选择PHP作为语言基础的总结，也会尽量以功能（比如字符串、数据库操作等）作为复习的着眼点。换一种语言，熟悉了语言的语法之后，就是按照这里的功能检索学习，也能很快开始后端的开发。 网络知识以HTTP为主，也要了解TCP/IP以及UDP相关的知识。 数据库SQL 语言、事务、锁、索引，传统的数据库系统对于后端来说，说来说去其实就是这些东西。NOSQL方面更多需要的是对各种数据库做一个了解，知道不同数据库的适应方向，在实际应用的时候知道如何取舍。 缓存很少有人会提这一块内容。但是缓存其实对后端开发来说非常重要。后端开发中，很多地方都涉及到缓存。缓存的使用没有定式，可能只会讲讲自己的一些经验。 消息队列上面这些基本事纯后端的知识，而且基本事面向业务开发。其他还有两个大的组成，一个机计算机基础知识，一个是系统架构设计。这两块的内容，在开发中不那么日常，但也很重要，等有时间再做整理了。","link":"/2018/10/09/%E6%95%B4%E7%90%86/"},{"title":"最好的 Linux 发行版","text":"Linux 作为一个操作系统，在服务器领域尤其是 web 服务器来说，一直是一个很好的选择，相对于 Windows server 高额的授权费用，免费开源的 Linux 更受个人和有开发能力的公司的青睐。甚至在市场份额上，还略微高于 Windows Server。但在桌面端，似乎一直是 geek 的玩物，哪怕是 web 开发，有钱的直接上 MacOS，没钱的想方设法组黑苹果。除了驱动不完善之外（现在情况已经大大改善了），最主要的还是 Linux 的桌面端应用相比其他两个操作系统生态来说，还是太少太少。一些仅有的软件，对比之下质量也只是勉强可用的地步。 但是，作为一个web开发者，不熟悉 Linux 系统，可以说是一个重大的技能缺陷。因为不论你怎么躲，都躲不开 Linux 系统的使用。哪怕你用的的 .Net，难道你就不看看 .Net core 了嘛。诚然，我们日常使用中并不会使用到太多的功能。即使常用如看日志，实在不行就拉到本地来看嘛。但如果会用 head、tail、less、grep，那基本的查询分分钟搞定，再如果会用 sed、awk，简单的日志统计也是不在话下。 我认为对 Linux 常用的命令和工具有基本的了解，知道什么情况下可以用什么，是每个有志向的 web 开发者的基本能力之一。 但是（凡事都有个但是），作为日常操作系统，linux 是真难用。特别是中国这种特殊国情，没有QQ，没有微信，基本就丧失了日常使用的可能。不要说web版、wine版，那都是没有办法的办法。也难怪，web 开发们都用 mac。甚至从某种角度讲，MacOS 是 Linux 的替代品，虽然有些不同，但同出于 *nix 门下的 MacOS，相比 Windows 还是更接近生产环境一些，各种工具链也基本一致。 直到微软在 Build 2016 大会，宣布了 Bash on Windows。正式的名称是Windows Subsystem for Linux，简称 WSL。简单来说，Windows 的 NT 内核在设计之初就可以支持多种子系统，只要封装 NT 的系统调用为对应系统的 API 即可为应用系统提供支持。具体原理可以参看Windows Subsystem for Linux Overview。英文看着累的话，知乎上有对应的中文翻译。 经过一年的开发与完善，在今年的秋季更新中，WSL 结束测试，进入应用商店, Bash on Windows 这个名称也不再使用。Windows10 就这样成为了“最好的 Linux 发行版”。 如果开发工作涉及 Linux 的底层，特别是驱动级别的开发，UI 开发还是需要虚拟系统，或者最好是原生系统，这方面不太了解，也不班门弄斧了。但就 Linux 的入门学习和一般的服务器端开发工作来说, WSL 已经完全可以胜任。虽然在与开发工具的集成上还有一些问题（大多数的开发工具还不支持调用 WSL 里的工具链, VsCode 已经在做相关工作），但问题不大。对于web开发来说，编译运行这些工作这些使用命令行处理也不繁琐，个人也更喜欢使用命令行。而 vim 和 emacs 用户，则几乎不存在什么问题了。 我最近切换到了 window10 与 WSL 的组合，经过最初几天的适应，现在已经非常顺手。就开发而言，基本没有什么不同了。至于如何启用WSL，网上有太多文章了。这里是微软的官方教程。","link":"/2017/12/10/%E6%9C%80%E5%A5%BD%E7%9A%84Linux%E5%8F%91%E8%A1%8C%E7%89%88/"},{"title":"死亡","text":"有一个画面在脑中如金属上的刻痕一般深刻：夏蝉鸣得人心烦躁，炙烤下的水泥地面腾起看不见的雾气扭曲了视线，瘦弱的男孩半黑不白，穿装背心短裤，从二楼的窗户探出大半个身子凝望着地面。如果从这里跳下去，是不是就死了？这可能是我第一次，对死亡这件事产生思考。 死了会怎么样，死了似乎也不会怎么样。死了就死了吧。也许是小孩子尚不懂得死亡的意义，但这个基调却在心里持续了很久。死了，也就死了吧。 第二次对死亡的印象是爷爷去世的时候。看着爷爷安静地躺着，除了因大量失血而苍白的嘴唇外，看起来不过就是睡着了。姑姑抵达时见到此景一声哭腔喊出，却被奶奶喝住了：现在还不能哭。姑姑收住了哭声，我没看清是否流泪。但守灵当夜，我确实清楚得看到，父亲站门口台阶之上，肩膀耸动，手抹着眼睛。这是我第一次看到父亲哭泣。 我跑进灵堂，看着安静的躺着的爷爷。守灵的亲戚奶奶对我说再看看吧，再看看吧，以后就再也看不到了。我回忆起每次疯玩一圈回来，都要把爷爷那个被茶渍染成深褐色的大号透明塑料茶杯里的茶水喝个精光，爷爷嘟囔着我每次都喝光不剩然后默默续上水。我终于大哭了起来。一直到现在，关于爷爷的最深的印象就是那个大茶杯，只是后来再也没有从那样的大杯子里喝过茶水了。 (于飞往昆明航班之上)","link":"/2018/03/05/%E6%AD%BB%E4%BA%A1/"},{"title":"输入与输出","text":"最近一直在思考关于信息的输入与输出的问题。 每天，我们都在接受大量的信息。以我自己来说，微信、微博、知乎这些碎片化的；书籍、教程，公开课，MOOC这些系统化的。并且，花在前者中的时间越来越多，在每天所获取的信息中占的比重越来越大。每天都在接受海量的信息，可是躺在床上睡不着的时候却总是无事可想。（也许也不错，越想越睡不着） 另一个感受就是无事可写。 我不喜欢用博客做笔记，尤其是把别人写过的东西再写一遍。复制粘贴然后当做自己的产出，那真是一件很无聊的事。文笔不好，所以也不喜欢写太多的随笔记录；个人习惯也不喜欢公开私人生活，所以几乎不写这类的博客。那么，写些什么呢。以前的内容通常都是思考和总结，读书然后化到自己的生活中，出现自己的体会，再慢慢地转化成思索，最后输出成文字。 而现在，我觉得没有什么可以写了。有的时候会有一些简短的思索出现，但是能成型的文字，通常仅仅足够发一个朋友圈，再多也没有了。碎片化的输入，导致了碎片化的输出。 在我的观念中，信息的输出是输入知识化的体现。所谓知识化，就是指经过个人对输入的信息经过加工，形成可以传递下去的经验或见解。而其中又可分整理型的和创造型的输出。而碎片化输入的零星内容，在没有相关的知识背景的情况下很难作为归纳总结的对象，又不够作为创造的工具组件，所以很难形成有效知识化过程。更何况，我们日常接触的信息碎片，有多少是真正有价值的呢。 在有了这样的认识之后，我删除了自己手机中的所有的碎片化阅读工具，只保留了feedly作为收集各类碎片内容的信息源, 每天花费少量的时间过一遍，并选取可能作为自己知识组件的部分或者单纯为了娱乐阅读。 在节约了一些时间之后，我考虑重新开始系统化输入的事情。简单来说就是，自大学毕业甚至是大学停课以来，我就没有真正完整的看过一本知识类的书籍了。这时还没有特别需要深入的方向，所以就是由着兴趣来读了。挑来挑去，发现自己还是对计算机最感兴趣，又自感相关基础薄弱，便决定从计算机基础开始。 然而，工作的排期和生活琐碎已经挤占了大部分的时间，再回忆起大学时期游戏动漫苦闷想入非非的那些时光，除了怀念还带上了一些惭愧，也才真正理解老师那句恨铁不成钢的：大学是学习的最好时间。","link":"/2016/06/15/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"title":"静心做事","text":"乐空空上两个版本周期中，抛开所有业务上的事，把我自己认为乐空空在 Laravel 上应该改的基础架构都改了。在快接近尾声的时候，发现自己似乎已经没什么想要做的事了。这个时候已经开始焦虑了：我绝的乐空空应该还有还有很多事要做，为什么到这里就没事可做了呢？我的能力到头了或者这个产品目前到头了。刚好这时候版本开发出现了延误，闲而又闲之下就琢磨，越琢磨越觉得现在的开发流程有问题，但觉得自己不出在管理的职位上，并不应该去管理这些事情。一来感觉无事可做，而来对产品没信心，三来觉得无力改变现状，所以看待什么都很消极。 向前辈咨询，被领导谈话。经过各种各样的梳理和解压，脑子渐渐冷静下来。再次慢慢回想这些事情，确实整个团队是有一些问题，但出现那样的强烈的负面情绪，问题还是在自己身上。本质的原因还是对自己能力的怀疑。在有事可以忙碌的时候，精神专注在解决问题上，没有经历去考虑这些问题，但一旦闲下来，就会不停地想：我到底掌握了那些东西？掌握到多少程度？我到底可以解决多大程度问题？我解决的问题到底价值几何？我到底价值几何？ 有这些疑问的原因其实一直都很清楚。第一，我一直耿耿于怀自己非专业的出生，觉得自己在很多基础的问题上掌握不好；第二，在没有考试和分数之后，已经失去了对自己能力的衡量方式。问题很明确，但是一直都没有很明确的办法。 也做过很多目的并不明确的尝试。比如做很多个人项目，并希望通过个人项目掌握不同的技能；比如考虑过考研，甚至投递国外大学的硕士申请；比如尝试去看大学的计算机教程。但很多尝试最后都不了了之。放弃的原因就是觉得要么无法改变问题一，要么无法解决问题二。 其实，还有问题三。我的内心很焦躁，很着急。我希望我可以快速地把别人多年的积累补起来，我希望可以快速地积累财富，我希望自己可以快速的变好。当我意识到自己工作两年了，虽然感觉自己有一些长进，但是不明白自己长进在哪里，似乎还是和以前差不多时候，我觉得我太慢了。所更加焦躁。昨天和女朋友谈心，虽然成因不同，她也有同样的心理。分析她的心理的时候，才意识自己表面冷静，其实也是半斤八两。 怎么办？其实也好办。让自己平静下来，把自己认为应该补的东西补上来，找一种衡量自己补的好不好方法，两个问题就都解决了。然而，就和鸡汤一样，大道理谁都懂。 还是要有一些实际的方法，毕竟我是一个那么会做计划的人，也是我觉得自己唯一不比比人弱的地方。 现在是工作两个，我希望在我工作三年的时候，以上的两个问题都不在是问题，也就是给自己一年时间来解决这些问题。 不在开新的个人项目，原来的项目该放弃放弃，可以完善的完善但是尽快阶段性结束，不在考虑自己的框架之类虚无缥缈的事。有任何的主意可以记着，可以写成类似项目规划的东西防止忘记。认真学习自己认为应该补习的东西，做好练习题，练习题就是衡量。刷 LeetCode, 这真的是最直接的能力衡量了。 需要加强工作的总结。这一点其实挺重要的，毕竟生活中大部分时间都在工作。如果说要明确自己能力，也许可以列出自己曾经解决过什么样的问题如何解决的是最具说服力的了。可以用文章的形式写出来，也可用代码的形式的来表述。程序员么，还是 show me the code。 愿自己如网名 jswh 原本的意义一样，平静而底蕴深厚，宠辱不惊。","link":"/2016/07/10/%E9%9D%99%E5%BF%83%E5%81%9A%E4%BA%8B/"}],"tags":[],"categories":[]}